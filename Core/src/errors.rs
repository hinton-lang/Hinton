use std::path::Path;

use crate::tokens::{TokenIdx, TokenList};
use crate::RuntimeResult;

/// Represents an error generated by the Parser or the compiler.
pub struct ErrorReport {
  /// The source line of the error.
  pub line_num: usize,
  /// The line start position where the error occurred.
  pub line_start: usize,
  /// The span of the offending characters/tokens in the source code.
  pub span: (usize, usize),
  /// The error message to display for this error report.
  pub message: String,
}

/// Represents the types of errors that can occur during
/// execution of the compiled bytecode.
pub enum RuntimeErrorType {
  ArgumentError,
  AssertionError,
  IndexError,
  InstanceError,
  Internal,
  KeyError,
  RecursionError,
  ReferenceError,
  StopIteration,
  TypeError,
  ZeroDivision,
}

/// Represents the types of errors that can occur during compilation
/// of the abstract syntax tree into bytecode.
pub enum CompilerErrorType {
  MaxCapacity,
  Reassignment,
  Reference,
  Syntax,
  Duplication,
}

/// Represents the types of errors that can occur while performing
/// some operation between Hinton objects.
pub enum ObjectOprErrType {
  TypeError(String),
  IndexError(String),
  ZeroDivisionError(String),
  KeyError(String),
}

impl ObjectOprErrType {
  /// Converts an Object Operation Error into a Runtime Result Error.
  pub fn to_runtime_error(&self) -> RuntimeResult {
    match self {
      ObjectOprErrType::TypeError(msg) => RuntimeResult::Error {
        error: RuntimeErrorType::TypeError,
        message: msg.to_owned(),
      },
      ObjectOprErrType::IndexError(msg) => RuntimeResult::Error {
        error: RuntimeErrorType::IndexError,
        message: msg.to_owned(),
      },
      ObjectOprErrType::ZeroDivisionError(msg) => RuntimeResult::Error {
        error: RuntimeErrorType::ZeroDivision,
        message: msg.to_owned(),
      },
      ObjectOprErrType::KeyError(msg) => RuntimeResult::Error {
        error: RuntimeErrorType::KeyError,
        message: msg.to_string(),
      },
    }
  }
}

/// Emits a compiler error from the given token.
///
/// # Parameters
/// - `tokens_list`: A reference to the list of lexed tokens.
/// - `tok`: The token that caused the error.
/// - `kind`: The error message kind to display.
/// - `msg`: The error message to display.
pub fn error_at_tok(tokens_list: &TokenList, tok_idx: TokenIdx, kind: &str, msg: &str) -> ErrorReport {
  let tok = tokens_list[tok_idx].get_location();
  let ln = tok.line_num;
  let cs = tok.col_start;

  // Construct the error message.
  let msg = format!("\x1b[31;1m{}\x1b[0m\x1b[1m at [{}:{}]: {}\x1b[0m", kind, ln, cs, msg);

  ErrorReport {
    line_num: ln,
    line_start: tok.line_start,
    span: tok.span,
    message: msg,
  }
}

/// Reports an error list coming from the Parser or compiler.
///
/// # Parameters
/// - `filepath`: The file path of where the errors occurred.
/// - `errors`: An `ErrorList` containing the errors.
/// - `source`: A reference to the source contents.
pub fn report_errors_list(filepath: &Path, errors: Vec<ErrorReport>, source: &[char]) {
  let source_str = source.iter().collect::<String>();
  let source_lines: Vec<&str> = source_str.split('\n').collect();

  for error in errors.iter() {
    eprintln!("{}", error.message);
    print_error_source(filepath, error.line_num, error.line_start, error.span, &source_lines);
  }

  eprintln!("\x1b[31;1mERROR:\x1b[0m Aborted execution due to previous errors.");
}

/// Prints the filepath and a snippet of the source line associated with a Parser or compiler error.
///
/// # Parameters
/// - `filepath`: The file path of where the errors occurred.
/// - `ln`: The source line number of the error.
/// - `ls`: The line start position where the error occurred.
/// - `span`: The span of the offending characters/tokens in the source code.
/// - `lines`: A reference to a vector with the source lines.
fn print_error_source(filepath: &Path, ln: usize, ls: usize, span: (usize, usize), lines: &[&str]) {
  let front_pad = (f64::log10(ln as f64).floor() + 1f64) as usize;
  let line = lines.get(ln - 1).unwrap();

  eprintln!(" {}---> File '{}'.", "-".repeat(front_pad), filepath.to_str().unwrap());
  print_error_snippet(ln, ls, span, line);
}

/// Prints a snippet of the source line associated with an error.
///
/// # Parameters
/// - `ln`: The source line number of the error.
/// - `ls`: The line start position where the error occurred.
/// - `span`: The span of the offending characters/tokens in the source code.
/// - `src`: A reference to the source error line.
pub fn print_error_snippet(ln: usize, ls: usize, span: (usize, usize), src: &str) {
  let front_pad = (f64::log10(ln as f64).floor() + 1f64) as usize;
  // +2 for one extra space at the front and one at the back
  let whitespace_pad_size = " ".repeat(front_pad + 2);

  // Compute the column of the error with trimmed whitespaces from the source line.
  let mut removed_whitespace = 0;
  for c in src.chars() {
    if c == ' ' {
      removed_whitespace += 1;
    } else {
      break;
    }
  }

  let trimmed_source = src.trim();

  let err_col = span.0 - ls - removed_whitespace;
  let err_len = span.1 - span.0;
  if !trimmed_source.is_empty() {
    eprintln!("{}|", whitespace_pad_size);
    eprint!(" {} | ", ln);
    eprintln!("{}", trimmed_source);
    eprint!("{}|", whitespace_pad_size);
    eprintln!(" {}\x1b[31;1m{}\x1b[0m", " ".repeat(err_col), "^".repeat(err_len));
  }

  eprintln!()
}
