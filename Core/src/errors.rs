use crate::RuntimeResult;
use std::path::Path;

/// Represents an error generated by the Parser or the compiler.
pub struct ErrorReport {
  /// The source line of the error.
  pub line: usize,
  /// The source column of the error.
  pub column: usize,
  /// The number of characters in the token(s) lexeme(s) that caused the error.
  pub lexeme_len: usize,
  /// The error message to display for this error report.
  pub message: String,
}

/// Represents the types of errors that can occur during
/// execution of the compiled bytecode.
pub enum RuntimeErrorType {
  ArgumentError,
  AssertionError,
  IndexError,
  InstanceError,
  Internal,
  KeyError,
  RecursionError,
  ReferenceError,
  StopIteration,
  TypeError,
  ZeroDivision,
}

/// Represents the types of errors that can occur during compilation
/// of the abstract syntax tree into bytecode.
pub enum CompilerErrorType {
  MaxCapacity,
  Reassignment,
  Reference,
  Syntax,
  Duplication,
}

/// Represents the types of errors that can occur while performing
/// some operation between Hinton objects.
pub enum ObjectOprErrType {
  TypeError(String),
  IndexError(String),
  ZeroDivisionError(String),
  KeyError(String),
}

impl ObjectOprErrType {
  /// Converts an Object Operation Error into a Runtime Result Error.
  pub fn to_runtime_error(&self) -> RuntimeResult {
    match self {
      ObjectOprErrType::TypeError(msg) => RuntimeResult::Error {
        error: RuntimeErrorType::TypeError,
        message: msg.to_owned(),
      },
      ObjectOprErrType::IndexError(msg) => RuntimeResult::Error {
        error: RuntimeErrorType::IndexError,
        message: msg.to_owned(),
      },
      ObjectOprErrType::ZeroDivisionError(msg) => RuntimeResult::Error {
        error: RuntimeErrorType::ZeroDivision,
        message: msg.to_owned(),
      },
      ObjectOprErrType::KeyError(msg) => RuntimeResult::Error {
        error: RuntimeErrorType::KeyError,
        message: msg.to_string(),
      },
    }
  }
}

/// Reports an error list coming from the Parser or compiler.
///
/// # Parameters
/// - `filepath`: The file path of where the errors occurred.
/// - `errors`: An `ErrorList` containing the errors.
/// - `source`: A reference to the source contents.
pub fn report_errors_list(filepath: &Path, errors: Vec<ErrorReport>, source: &[char]) {
  let source_str = source.iter().collect::<String>();
  let source_lines: Vec<&str> = source_str.split('\n').collect();

  for error in errors.iter() {
    eprintln!("{}", error.message);
    print_error_source(filepath, error.line, error.column, error.lexeme_len, &source_lines);
  }

  eprintln!("\x1b[31;1mERROR:\x1b[0m Aborted execution due to previous errors.");
}

/// Prints the filepath and a snippet of the source line associated with a Parser or compiler error.
///
/// # Parameters
/// - `filepath`: The file path of where the errors occurred.
/// - `line_num`: The source line number of the error.
/// - `col`: The source column number of the error.
/// - `len`: The length of the token that produced the error.
/// - `lines`: A reference to a vector with the source lines.
fn print_error_source(filepath: &Path, line_num: usize, col: usize, len: usize, lines: &[&str]) {
  let front_pad = (f64::log10(line_num as f64).floor() + 1f64) as usize;
  let line = lines.get(line_num - 1).unwrap();

  eprintln!(" {}---> File '{}'.", "-".repeat(front_pad), filepath.to_str().unwrap());
  print_error_snippet(line_num, col, len, line);
}

/// Prints a snippet of the source line associated with an error.
///
/// # Parameters
/// - `line_num`: The source line number of the error.
/// - `col`: The source column number of the error.
/// - `len`: The length of the token that produced the error.
/// - `src`: A reference to the source error line.
pub fn print_error_snippet(line_num: usize, col: usize, len: usize, src: &str) {
  let front_pad = (f64::log10(line_num as f64).floor() + 1f64) as usize;
  // +2 for one extra space at the front and one at the back
  let whitespace_pad_size = " ".repeat(front_pad + 2);

  // Compute the column of the error with trimmed whitespaces from the source line.
  let mut removed_whitespace = 0;
  for c in src.chars() {
    if c == ' ' {
      removed_whitespace += 1;
    } else {
      break;
    }
  }

  let col = col - removed_whitespace;
  let trimmed_source = src.trim();

  if !trimmed_source.is_empty() {
    eprintln!("{}|", whitespace_pad_size);
    eprint!(" {} | ", line_num);
    eprintln!("{}", trimmed_source);
    eprint!("{}|", whitespace_pad_size);
    eprintln!(" {}\x1b[31;1m{}\x1b[0m", " ".repeat(col), "^".repeat(len));
  }

  eprintln!()
}
