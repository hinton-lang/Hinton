use crate::tokens::{TokenIdx, TokenList, TokenLoc};

pub enum ErrMsg {
  /// A syntax error.
  Syntax(String),
  /// An identifier reference error.
  Reference(String),
  /// A reassignment error.
  Reassignment(String),
  /// An identifier duplication error.
  Duplication(String),
  /// Errors that occur only at runtime. Some of which can be
  /// caught by the programmer with a try-catch-finally block.
  Runtime(RuntimeErrMsg),
  /// An error emitted when the program finds an operation that
  /// cannot be encoded with one or two bytes of instructions.
  MaxCapacity(String),
  /// An error emitted when an internal process fails.
  Internal(String),
}

/// Errors that occur only at runtime. Some of which can be
/// caught by the programmer with a try-catch-finally block.
pub enum RuntimeErrMsg {
  /// An error emitted when there is a type mismatch.
  Type(String),
  /// An error emitted when an indexer is outside the bounds of a collection.
  Index(String),
  /// An error emitted when there is zero division.
  ZeroDivision(String),
  /// An error emitted when the programmer tries to access
  /// an unknown key in a dictionary.
  Key(String),
  /// An error emitted when an assertion fails.
  Assertion(String),
  /// An error emitted when there is an issue with a function argument.
  Argument(String),
  /// An error emitted when there is an issue with a class instance.
  Instance(String),
  /// An error emitted when there is a stack overflow.
  Recursion(String),
  /// An error emitted when there is an issue with referencing an identifier.
  Reference(String),
  /// An error emitted when accessing the next item in iterator after it has ended.
  IterStrop(String),
}

impl ErrMsg {
  /// Gets the display name of an error.
  pub fn name(&self) -> &str {
    match self {
      ErrMsg::Syntax(_) => "SyntaxError",
      ErrMsg::MaxCapacity(_) => "MaxCapacityError",
      ErrMsg::Reference(_) => "ReferenceError",
      ErrMsg::Reassignment(_) => "ReassignmentError",
      ErrMsg::Duplication(_) => "DuplicationError",
      ErrMsg::Internal(_) => "InternalError",
      // Runtime errors that can be caught with a try-catch-finally block.
      ErrMsg::Runtime(e) => match e {
        RuntimeErrMsg::Type(_) => "TypeError",
        RuntimeErrMsg::Index(_) => "IndexError",
        RuntimeErrMsg::ZeroDivision(_) => "ZeroDivisionError",
        RuntimeErrMsg::Key(_) => "KeyError",
        RuntimeErrMsg::Assertion(_) => "AssertionError",
        RuntimeErrMsg::Argument(_) => "ArgumentError",
        RuntimeErrMsg::Instance(_) => "InstanceError",
        RuntimeErrMsg::Recursion(_) => "RecursionError",
        RuntimeErrMsg::Reference(_) => "ReferenceError",
        RuntimeErrMsg::IterStrop(_) => "IterStopError",
      },
    }
  }

  /// Gets the display name of an error.
  pub fn message(&self) -> &str {
    match self {
      ErrMsg::Syntax(x)
      | ErrMsg::MaxCapacity(x)
      | ErrMsg::Reference(x)
      | ErrMsg::Reassignment(x)
      | ErrMsg::Internal(x)
      | ErrMsg::Duplication(x) => x,
      // Runtime errors. Some of which can be caught with a try-catch-finally block.
      ErrMsg::Runtime(e) => match e {
        RuntimeErrMsg::Type(x)
        | RuntimeErrMsg::Index(x)
        | RuntimeErrMsg::ZeroDivision(x)
        | RuntimeErrMsg::Key(x)
        | RuntimeErrMsg::Assertion(x)
        | RuntimeErrMsg::Argument(x)
        | RuntimeErrMsg::Instance(x)
        | RuntimeErrMsg::Recursion(x)
        | RuntimeErrMsg::Reference(x)
        | RuntimeErrMsg::IterStrop(x) => x,
      },
    }
  }
}

/// Represents an error generated by the Parser or the compiler.
pub struct ErrorReport {
  pub token: TokenIdx,
  /// The error message to display for this error report.
  pub err_msg: ErrMsg,
  // A hint, if any, to display about the error.
  pub hint: Option<String>,
}

/// Emits an error from the given token.
///
/// # Parameters
/// - `tokens_list`: A reference to the list of lexed tokens.
/// - `tok`: The token that caused the error.
/// - `msg`: The error message to display.
pub fn error_at_tok(token: TokenIdx, err_msg: ErrMsg, hint: Option<String>) -> ErrorReport {
  ErrorReport { token, err_msg, hint }
}

/// Reports an error list coming from the Parser or compiler.
///
/// # Parameters
/// - `filepath`: The file path of where the errors occurred.
/// - `errors`: An `ErrorList` containing the errors.
/// - `source`: A reference to the source contents.
pub fn report_errors_list(tokens_list: &TokenList, errors: Vec<ErrorReport>) {
  let source_str = tokens_list.src.iter().collect::<String>();
  let source_lines: Vec<&str> = source_str.split('\n').collect();

  for error in errors.iter() {
    let tok = tokens_list[error.token].loc;
    let ln = tok.line_num;
    let cs = tok.col_start();

    // Construct the error message.
    let err_msg = &error.err_msg;
    let kind = err_msg.name();
    let msg = err_msg.message();

    // Prints the error message
    eprintln!("\x1b[31;1m{}\x1b[0m\x1b[1m at [{}:{}]: {}\x1b[0m", kind, ln, cs, msg);

    // Prints the error source file path
    let front_pad = (f64::log10(ln as f64).floor() + 1f64) as usize;
    let line = source_lines.get(ln - 1).unwrap();
    let filepath = tokens_list.filepath.to_str().unwrap();
    eprintln!(" {}---> File '{}'.", "-".repeat(front_pad), filepath);

    // Prints a snippet of the error source and an error hint, if it exists.
    print_error_snippet(tok, line, &error.hint);
  }

  eprintln!("\x1b[31;1mERROR:\x1b[0m Aborted execution due to previous errors.");
}

/// Prints a snippet of the source line associated with an error.
///
/// # Parameters
/// - `ln`: The source line number of the error.
/// - `ls`: The line start position where the error occurred.
/// - `span`: The span of the offending characters/tokens in the source code.
/// - `src`: A reference to the source error line.
pub fn print_error_snippet(tok: TokenLoc, line: &str, hint: &Option<String>) {
  let front_pad = (f64::log10(tok.line_num as f64).floor() + 1f64) as usize;
  // +2 for one extra space at the front and one at the back
  let whitespace_pad_size = " ".repeat(front_pad + 2);

  // Compute the column of the error with trimmed whitespaces from the source line.
  let removed_whitespace = line.chars().take_while(|ch| ch.is_whitespace()).count();
  let line = line.trim().to_string();
  let err_col_start = tok.col_start() - removed_whitespace;
  let err_col_end = err_col_start + (tok.span.1 - tok.span.0);
  let ellipsis = "\x1b[1m\x1b[38;5;3m...\x1b[0m";

  // Clip surrounding characters if the line is too long.
  let (trimmed_source, err_col_start) = if err_col_start > 20 && (line.len() - err_col_end) > 20 {
    let err = &line[(err_col_start - 20)..(err_col_end + 20)];
    (format!("{ellipsis}  {}  {ellipsis}", err), 25)
  } else if err_col_start > 40 {
    let err = &line[(err_col_start - 40)..];
    (format!("{}  {}", ellipsis, err), 45)
  } else if (line.len() - err_col_end) > 40 {
    let err = &line[..(err_col_end + 40)];
    (format!("{}  {}", err, ellipsis), err_col_start)
  } else {
    (line, tok.col_start() - removed_whitespace)
  };

  if !trimmed_source.is_empty() {
    eprintln!("{}|", whitespace_pad_size);
    eprint!(" {} | ", tok.line_num);
    eprintln!("{}", trimmed_source);
    eprint!("{}|", whitespace_pad_size);
    eprintln!(
      " {}\x1b[31;1m{}\x1b[0m",
      " ".repeat(err_col_start),
      "^".repeat(tok.span.1 - tok.span.0)
    );

    if let Some(h) = hint {
      eprintln!("{}| \x1b[38;5;35;1mHint:\x1b[0m {}", whitespace_pad_size, h);
    }
  }

  eprintln!()
}
