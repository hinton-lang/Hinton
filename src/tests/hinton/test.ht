// Test if-else statements
let initial = 3;
if (initial == 1 and true) {
    assert_eq(initial, 1);
} else if (initial == 2) {
    assert_eq(initial, 2);
} else if (initial == 3) {
    assert_eq(initial, 3);
} else {
    assert(initial > 3);
}

// Test ternary expressions
assert_eq(false ? "value 1" : true ? "value 2" : "value 3", "value 2");

// Test chained array indexing
let a = [1, 1 + 1, ["a", "b", "c", "d"], true, false, null];
let b = 1;
assert_eq(a[2][b], "b");


// Test function returns with optional parameters
func myFunction(a, b?, c := "named parameter") {
    return a + " " + b + " " + c;
}
assert_eq(myFunction("hello", "world"), "hello world named parameter");

// More testing of functions
func fib(n) {
    if (n < 2) return n;
    return fib(n - 2) + fib(n - 1);
}
assert_eq(fib(12), 144);

// More testing of functions
func fact(x) {
    if (x == 0) return 1;
    return x * fact(x - 1);
}
assert_eq(fact(12), 479001600);

// Ranges are equal if their bounds are equal
assert_eq(14..24, 14..24);
assert_ne(0..10, 0..9);

// Test negative indexing
let greetings = ["hello", "hola", "ciao"];
assert_eq(greetings[-2][1], "o"); // ["hello", "hola", "ciao"][-2][1] ==> "hola"[1] ==> "o"

// Test iterators
let array_iter = iter(greetings);
assert_eq(next(array_iter), "hello");
assert_eq(next(array_iter), "hola");
assert_eq(next(array_iter), "ciao");

let city = "New York";
let string_iter = iter(city);
assert_eq(next(string_iter), "N");
assert_eq(next(string_iter), "e");
assert_eq(next(string_iter), "w");
assert_eq(next(string_iter), " ");
assert_eq(next(string_iter), "Y");
assert_eq(next(string_iter), "o");
assert_eq(next(string_iter), "r");
assert_eq(next(string_iter), "k");


// Test accessing and modifying variables
// from within the scope of a child function.
func outer() {
  let x = "old value";

  func middle() {
      assert_eq(x, "old value");

      func inner() {
          assert_eq(x, "old value");
          x = "new value";
          assert_eq(x, "new value");
      }

      assert_eq(x, "old value");
      inner();
      assert_eq(x, "new value");
  }

  assert_eq(x, "old value");
  middle();
  assert_eq(x, "new value");
}

outer();


// Test closures
func func_with_closure() {
  let a = "initial";

  func set(k) { a = k; }
  func get() { return a; }

  return (set, get);
}

let called_func_with_closure = func_with_closure();

// Accesses the inner functions
let setter = called_func_with_closure[0];
let getter = called_func_with_closure[1];

assert_eq(getter(), "initial");

setter("value 1");
assert_eq(getter(), "value 1");

setter("some new value");
assert_eq(getter(), "some new value");


// Test for-in loops and array subscripting
let title_tags = ["h1", "h2", "h3", "h4", "h5", "h6"];
let tag_index = 0;
for let tag in title_tags {
    assert_eq(tag, title_tags[tag_index]);
    tag_index += 1;
}


// More Closures
let globalOne;
let globalTwo;

func main() {
    {
        let a = "one";
        
        func one() {
            return a;
        }
        
        globalOne = one;
    }
    
    {
        let a = "two";
        func two() {
            return a;
        }
        
        globalTwo = two;
    }
}

main();
assert_eq(globalOne(), "one");
assert_eq(globalTwo(), "two");


// Test closing over the loop variable
// Reuse these global variables
globalOne = null;
globalTwo = null;

for let a in 1..3 {
    func closure() {
        return a;
    }

    if (globalOne == null) {
        globalOne = closure;
    } else {
        globalTwo = closure;
    }
}

assert_eq(globalOne(), 1);
assert_eq(globalTwo(), 2);



// Test the continue statement
let odds = [1, 3, 5, 7, 9];
let ith = 0;

for let n in 0..10 {
    if ((n mod 2) == 0) continue;

    assert_eq(n, odds[ith]);
    ith += 1;
}
// Make sure the loop did not break early.
assert_eq(ith, 5);

let n = -1;
ith = 0;
while n < 10 {
    n += 1;
    if ((n mod 2) == 0) continue;

    assert_eq(n, odds[ith]);
    ith += 1;
}
// Make sure the loop did not break early.
assert_eq(ith, 5);
