use std::{cell::RefCell, rc::Rc};

use super::{Compiler, CompilerErrorType, CompilerType, SymbolType, UpValue};
use crate::{
    ast::*,
    bytecode::{self, OpCode},
    compiler::{
        symbols::{Symbol, SymbolTable},
        FunctionScope,
    },
    lexer::tokens::Token,
    objects::{FuncObject, Object},
};

impl Compiler {
    pub(super) fn compile_function_decl(&mut self, decl: &FunctionDeclNode) {
        match self.declare_symbol(&decl.name, SymbolType::Function) {
            Ok(parent_symbol_pos) => {
                let func_pos = (decl.name.line_num, decl.name.column_num);
                let prev_compiler_type = std::mem::replace(&mut self.compiler_type, CompilerType::Function);

                // The first element in a symbol table is always the symbol representing
                // the function to which the symbol table belongs.
                let symbols = SymbolTable::new(vec![Symbol {
                    name: decl.name.lexeme.clone(),
                    symbol_type: SymbolType::Function,
                    is_initialized: true,
                    symbol_depth: 0,
                    is_used: true,
                    line_info: func_pos,
                    is_captured: false,
                }]);

                // Make the this function declaration the
                // current function scope.
                self.functions.push(FunctionScope {
                    function: FuncObject {
                        defaults: vec![],
                        min_arity: decl.min_arity,
                        max_arity: decl.max_arity,
                        chunk: bytecode::Chunk::new(),
                        name: decl.name.lexeme.clone(),
                        up_val_count: 0,
                    },
                    s_table: symbols,
                    scope_depth: 0,
                    loops: vec![],
                    breaks: vec![],
                    up_values: vec![],
                });

                // Add the function's name to the pool of the function
                let fn_name = Object::String(Rc::new(RefCell::new(decl.name.lexeme.clone())));
                self.add_literal_to_pool(fn_name, &decl.name, false);
                // compiles the parameter declarations so that the compiler
                // knows about their their lexical scoping (their stack position),
                // but does not compile the default value for named parameters.
                self.compile_parameters(&decl.params);
                // Compile the function body
                self.compile_node(&decl.body);

                // Emit a return if the body does not end with a return
                if !decl.ends_with_return {
                    self.emit_return(&None, func_pos);
                }

                // When the 'show_bytecode' features flag is on, keep track of the
                // previous function's up_values so that we can pretty-print the
                // up_values captured by the closure.
                #[cfg(feature = "show_bytecode")]
                self.print_pretty_bytecode();
                #[cfg(feature = "show_raw_bytecode")]
                self.print_raw_bytecode();

                // Defines the function so that it can be loaded onto the stack.
                // When the function is first loaded onto the stack, it has no
                // default parameters initialized.
                let function = std::mem::take(&mut self.current_func_scope_mut().function);
                // Takes the up_values generated by the compiled function
                let up_values = std::mem::take(&mut self.current_func_scope_mut().up_values);

                // Go back to the previous function
                self.functions.pop();
                self.compiler_type = prev_compiler_type;

                // Loads the function object
                self.emit_function(function, up_values, &decl.name);

                // Compile the named parameters so that they can be
                // bound to the function at runtime.
                if decl.min_arity != decl.max_arity {
                    self.compile_named_parameters(decl);
                }

                // If we are in the global scope, declarations are
                // stored in the VM.globals hashmap
                if self.is_global_scope() {
                    self.define_as_global(&decl.name);
                    self.globals.mark_initialized(parent_symbol_pos);
                } else {
                    // Marks the variables as initialized
                    // a.k.a, defines the variables
                    self.current_func_scope_mut()
                        .s_table
                        .mark_initialized(parent_symbol_pos);
                }
            }

            // We do nothing if there was an error because the `declare_symbol()`
            // function takes care of reporting the appropriate error for us.
            // Explicit `return` to stop the loop.
            Err(_) => return,
        }
    }

    fn emit_function(&mut self, function: FuncObject, up_values: Vec<UpValue>, token: &Token) {
        let func = Object::Function(Rc::new(RefCell::new(function)));

        // If the function does not close over any values, then there is
        // no need to create a closure object at runtime.
        if up_values.len() == 0 {
            self.add_literal_to_pool(func, token, true);
            return;
        }

        let func_pos = (token.line_num, token.column_num);

        // Add the function object to the literal pool of the parent function
        if let Some(idx) = self.add_literal_to_pool(func, token, false) {
            if idx < 256 {
                if up_values.len() < 256 {
                    self.emit_op_code_with_byte(OpCode::MakeClosure, idx as u8, func_pos);

                    for up in up_values {
                        self.emit_raw_byte(if up.is_local { 1u8 } else { 0u8 }, func_pos);
                        self.emit_raw_byte(up.index as u8, func_pos);
                    }
                } else {
                    self.emit_op_code_with_byte(OpCode::MakeClosureLarge, idx as u8, func_pos);

                    for up in up_values {
                        self.emit_raw_byte(if up.is_local { 1u8 } else { 0u8 }, func_pos);
                        self.emit_short(up.index as u16, func_pos);
                    }
                }
            } else {
                if up_values.len() < 256 {
                    self.emit_op_code_with_short(OpCode::MakeClosureLong, idx, func_pos);

                    for up in up_values {
                        self.emit_raw_byte(if up.is_local { 1u8 } else { 0u8 }, func_pos);
                        self.emit_raw_byte(up.index as u8, func_pos);
                    }
                } else {
                    self.emit_op_code_with_short(OpCode::MakeClosureLongLarge, idx, func_pos);

                    for up in up_values {
                        self.emit_raw_byte(if up.is_local { 1u8 } else { 0u8 }, func_pos);
                        self.emit_short(up.index as u16, func_pos);
                    }
                }
            }
        }
    }

    fn compile_named_parameters(&mut self, decl: &FunctionDeclNode) {
        // Compiles the named parameters so that they can be on top
        // of the stack when the function gets composed at runtime.
        for param in &decl.params {
            match &param.default {
                Some(expr) => {
                    self.compile_node(&expr);
                }
                None => {
                    if param.is_optional {
                        self.emit_op_code(OpCode::LoadImmNull, (param.name.line_num, param.name.column_num));
                    }
                }
            }
        }

        // Once all the named parameter expressions are compiled, we bind
        // each of the named parameters to the function
        self.emit_op_code_with_byte(
            OpCode::BindDefaults,
            (decl.max_arity - decl.min_arity) as u8,
            (decl.name.line_num, decl.name.column_num),
        );
    }

    pub(super) fn compile_parameters(&mut self, params: &Vec<Parameter>) {
        for param in params.iter() {
            match self.declare_symbol(&param.name, SymbolType::Parameter) {
                Ok(_) => {
                    // Do nothing after parameter has been declared. Default
                    // values will be compiled by the function's parent scope.
                }
                // We do nothing if there was an error because the `declare_symbol()`
                // function takes care of reporting the appropriate error for us.
                // Explicit `return` to stop the loop.
                Err(_) => return,
            }
        }
    }

    pub(super) fn compile_return_stmt(&mut self, stmt: &ReturnStmtNode) {
        if let CompilerType::Script = self.compiler_type {
            self.error_at_token(
                &stmt.token,
                CompilerErrorType::Syntax,
                "Cannot return outside of function.",
            );
            return;
        }

        self.emit_return(&stmt.value, (stmt.token.line_num, stmt.token.column_num))
    }

    fn emit_return(&mut self, value: &Option<Box<ASTNode>>, token_pos: (usize, usize)) {
        if let Some(node) = value {
            self.compile_node(node);
        } else {
            self.emit_op_code(OpCode::LoadImmNull, token_pos);
        }

        let depth = self.relative_scope_depth();

        let symbols = self
            .current_func_scope_mut()
            .s_table
            .pop_scope(depth, false, false);

        for (i, is_captured) in symbols.iter().rev().enumerate() {
            if *is_captured {
                if i < 256 {
                    self.emit_op_code_with_byte(OpCode::CloseUpVal, i as u8, token_pos)
                } else {
                    self.emit_op_code_with_short(OpCode::CloseUpValLong, i as u16, token_pos);
                }
            }
        }

        self.emit_op_code(OpCode::Return, token_pos);
    }
}
