program         -> declaration* EOF ;

# Declarations ===============================================================

declaration     -> varDecl
                | constDecl
                | classDecl
                | function
                | statement ;

varDecl         -> "let" IDENTIFIER ( "," IDENTIFIER )* ( "=" expression )? ";" ;
fielDecl        -> "final"? IDENTIFIER ( "," IDENTIFIER )* ( "=" expression )? ";"
constDecl       -> "const" IDENTIFIER ( "," IDENTIFIER )* "=" expression ";" ;
classDecl       -> "class" IDENTIFIER "{" classMember* "}" ;

function        -> "func" IDENTIFIER "(" parameters? ")" block ;

classMember     -> ("public" | "private") "static"? (fielDecl | function) ;

parameters      -> IDENTIFIER ( "," IDENTIFIER )* ;

# Satatements ================================================================

statement       -> exprStmt
                | ifStmt
                | whileStmt
                | forStmt
                | breakStmt
                | contiueStmt
                | returnStmt
                | importStmt
                | block ;

whileStmt       -> "while" "(" expression ")" statement ;
forStmt         -> "for" "(" ( varDecl | exprStmt | ";" ) expression? ";" expression? ")" statement ;

ifStmt          -> "if" "(" expression ")" statement ( "else" statement )? ;

breakStmt       -> "break" ";"? ;
continueStmt    -> "continue" ";"? ;
returnStmt      -> "return" expression? ";"? ;

block           -> "{" declaration* "}" ;

importStmt      -> "import" STRING ";"? ;

exprStmt        -> expression ";"? ;


# Expressions ================================================================

expression      -> assignment ;
assignment      -> ( (call | indexing | instance | memberAccess) "." )? IDENTIFIER "=" assignment
                | logic_or ;
logic_or        -> logic_and ("||" logic_and)* ;
logic_and       -> equality ("&&" equality)* ;
equality        -> comparison ( ( "!=" | "==" ) comparison )* ;
comparison      -> term ( ( ">" | ">=" | "<" | "<=" ) term )* ;
term            -> factor ( ( "-" | "+" ) factor )* ;
factor          -> expo ( ( "/" | "*" | "%" ) expo )* ;
expo            -> unary ("**" unary)* ;
unary           -> ( "!" | "-" | "+" ) unary
                | indexing
                | lambda
                | instance
                | memberAccess
                | call ;

call            -> primary ( "(" arguments? ")" )* ;
indexing        -> primary ( "[" expression "]" )* ;
instance        -> "new" primary "(" arguments? ")" ;
memberAccess    -> primary ("." IDENTIFIER)* ;
lambda          -> "func" "(" parameters? ")" block ;

primary         -> INTEGER | REAL | STRING
                | "true" | "false" | "null"
                | "(" expression ")"
                | array
                | IDENTIFIER ;

array           -> "[" (expression ("," expression)*)? "]" ;

arguments       -> expression ( "," expression )* ;